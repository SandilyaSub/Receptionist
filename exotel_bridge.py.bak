import asyncio
import base64
import json
import logging
import os
import audioop

from google import genai
from google.genai import types
import websockets

# Configure logging
logging.basicConfig(level=logging.INFO)

# --- Gemini API Configuration ---
# It's recommended to use environment variables for sensitive data like API keys.

# This is the detailed system instruction for the bakery receptionist persona.
SYSTEM_INSTRUCTIONS = """You are working as a receptionist at this bakery taking user orders. 
Be courteous and respond properly. Do this in an Indian accent.

Towards the start of the conversation , ask the customer for his name , so that you can use that to address him during the conversation.

At the end of the conversation , the expectation is that you would have figured out all the relevant details that a baker needs to make a cake and keep it ready. You will tell the customer the price that would be incurred and a timeslot by when the cake would be ready, so that he could pick it up. The menu is towards the bottom of the instructions. The time a customer can come and pick the cake up would be 6hrs for making the cake and the cake is made only during the working hours. 

Typical preferences that customers would need to hear from you are - 
- flavour of the cake ,
- egg / eggless , 
- add-ons that are required like chocolates / some sprinkles , 
- size of the cake in KGs , 
- shape of the cake & occasion
- what is to be written on the cake or any further customizations.


DONOT ANSWER ANY IRRELEVANT QUESTIONS THAT ARE BEYOND THE SCOPE MENTIONED HERE. IF A CUSTOMERS ASKS SUCH A QUESTION POLITELY REPLY THAT YOU ARE SORRY AND CAN'T ANSWER THAT QUESTION AT THIS TIME. 

If a difficult question for which you are unsure of what the answer could be is asked , just reply to the customer that someone from the store will call you back during the next available working hour slot. 
---------------------------
Menu
Open Hours: 10am - 9pm

Cakes
(All cakes available in Half Kg / 1 Kg sizes)

Cake Name	Half Kg	1 Kg
(v) Dutch Truffle	RS 700	RS 1100"""

# Load API key from environment variable or use a default for local testing
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY", "AIzaSyDmnCmel5kqMzi7ShnbNiYrcUxzA_kaDkM")

client = genai.Client(api_key=GEMINI_API_KEY, http_options={"api_version": "v1beta"})

# Configuration for Gemini session
GEMINI_CONFIG = {
    "system_instruction": SYSTEM_INSTRUCTIONS,
    "response_modalities": ["audio"],
    "speech_config": {
        "voice": {
            "name": "alloy"
        }
    }
}

# Menu items (part of the system instructions)
# (v) Fruit Premium	RS 700	RS 1100
# (v) Pineapple	RS 600	RS 900
# (v) Dark Forest	RS 650	RS 950
# (v) Butterscotch	RS 650	RS 950
# (v) German Chocolate Cake	RS 700	RS 1100
# (v) Ferroro Rocher Cake	RS 800	RS 1300
# (v) Irish Coffee	RS 650	RS 950
# Carrotcake	RS 650	RS 950
# Blueberry Cheesecake (Cold Set)	RS 800	RS 1300
# Tiramisu	RS 800	RS 1300
# New York Cheesecake	RS 800	RS 1300

# Notes:

# GST: 5% Extra

# Cakes marked with (v) can be made eggless with an additional charge of RS 30 for 500 grams and RS 60 for 1 kg.

# Products marked as eggless are also free from gelatin."""

# Configuration for Gemini session
GEMINI_CONFIG = {
    "system_instruction": SYSTEM_INSTRUCTIONS,
    "response_modalities": ["audio"],
    "speech_config": {
        "voice": {
            "name": "alloy"
        }
    }
}

# --- Audio Configuration ---
EXOTEL_SAMPLE_RATE = 8000
GEMINI_SAMPLE_RATE = 16000  # Gemini supports 16k and 24k. 16k is sufficient.
AUDIO_CHANNELS = 1
AUDIO_WIDTH = 2  # 16-bit PCM = 2 bytes

# --- Audio Utilities ---

def resample_audio(data: bytes, from_rate: int, to_rate: int) -> bytes:
    """Resamples audio data using audioop."""
    try:
        # audioop.ratecv returns (new_data, new_state)
        resampled_data, _ = audioop.ratecv(data, AUDIO_WIDTH, AUDIO_CHANNELS, from_rate, to_rate, None)
        return resampled_data
    except audioop.error as e:
        logging.error(f"Audio resampling failed: {e}")
        return data # Return original data on error

# --- WebSocket Handler Tasks ---

async def forward_to_gemini(websocket, gemini_session):
    """Receives audio from Exotel, processes it, and sends it to Gemini."""
    silence_counter = 0
    max_silence_frames = 5  # Number of silent frames before sending end marker
    last_audio_time = None
    silence_timeout = 1.0  # Seconds of silence to trigger end marker
    
    while True:
        try:
            message = await websocket.recv()
            data = json.loads(message)

            # Process only media messages
            if data.get("event") == "media":
                media_payload = data.get("media", {}).get("payload")
                if media_payload:
                    # 1. Decode from Base64
                    raw_audio = base64.b64decode(media_payload)
                    
                    # Check if this is silence (very low amplitude)
                    is_silence = False
                    if len(raw_audio) > 0:
                        # Simple silence detection - check if max amplitude is below threshold
                        try:
                            max_amplitude = max(abs(b - 128) for b in raw_audio) if len(raw_audio) > 0 else 0
                            is_silence = max_amplitude < 5  # Threshold for silence
                            
                            if is_silence:
                                silence_counter += 1
                                logging.info(f"Detected silence frame {silence_counter}/{max_silence_frames}")
                            else:
                                silence_counter = 0
                                last_audio_time = asyncio.get_event_loop().time()
                        except Exception as e:
                            logging.error(f"Error in silence detection: {e}")
                    
                    # 2. Resample from 8kHz to 16kHz
                    resampled_audio = resample_audio(raw_audio, EXOTEL_SAMPLE_RATE, GEMINI_SAMPLE_RATE)
                    
                    # 3. Send to Gemini with proper MIME type
                    await gemini_session.send_realtime_input(audio=types.Blob(
                        data=resampled_audio,
                        mime_type=f"audio/pcm;rate={GEMINI_SAMPLE_RATE}"
                    ))
                    
                    # If we've detected enough silence, send a text message to signal end of audio
                    current_time = asyncio.get_event_loop().time()
                    if silence_counter >= max_silence_frames or \
                       (last_audio_time and current_time - last_audio_time > silence_timeout):
                        logging.info("Detected end of speech, sending end marker")
                        # Send a text message to signal end of audio
                        await gemini_session.send_realtime_input(text="[END_OF_AUDIO]")
                        silence_counter = 0

        except websockets.exceptions.ConnectionClosed:
            logging.info("Client connection closed in forward_to_gemini.")
            # Send end marker when connection closes
            try:
                await gemini_session.send_realtime_input(text="[END_OF_AUDIO]")
                logging.info("Sent end-of-audio marker after connection closed")
            except Exception as e:
                logging.error(f"Error sending end marker: {e}")
            break
        except Exception as e:
            logging.error(f"Error in forward_to_gemini: {e}", exc_info=True)
            break

async def forward_to_exotel(websocket, gemini_session):
    """Receives audio from Gemini, processes it, and sends it back to Exotel."""
    logging.info("Starting to listen for responses from Gemini...")
    try:
        async for response in gemini_session.receive():
            logging.info(f"Received response from Gemini: {type(response)}")
            
            # Log all available attributes and their values for debugging
            for attr in dir(response):
                if not attr.startswith('_'):
                    try:
                        value = getattr(response, attr)
                        if callable(value):
                            logging.info(f"Response has callable attribute: {attr}")
                        else:
                            logging.info(f"Response.{attr} = {value}")
                    except Exception as e:
                        logging.info(f"Error accessing attribute {attr}: {e}")
            
            # Check for text responses
            if hasattr(response, 'text') and response.text:
                logging.info(f"Text response received: {response.text}")
            
            # Check for audio responses in different possible formats
            audio_data = None
            
            # Try different possible attribute names for audio data
            if hasattr(response, 'audio') and response.audio:
                audio_data = response.audio
                logging.info(f"Found audio in response.audio: {len(audio_data)} bytes")
            elif hasattr(response, 'audio_content') and response.audio_content:
                audio_data = response.audio_content
                logging.info(f"Found audio in response.audio_content: {len(audio_data)} bytes")
            elif hasattr(response, 'content') and hasattr(response.content, 'audio'):
                audio_data = response.content.audio
                logging.info(f"Found audio in response.content.audio: {len(audio_data)} bytes")
            
            # If we found audio data, process and send it
            if audio_data:
                try:
                    # 1. Resample from Gemini's rate down to Exotel's 8kHz
                    resampled_audio = resample_audio(audio_data, GEMINI_SAMPLE_RATE, EXOTEL_SAMPLE_RATE)
                    # 2. Encode to Base64
                    base64_audio = base64.b64encode(resampled_audio).decode('utf-8')
                    # 3. Wrap in Exotel's JSON format and send
                    exotel_payload = {
                        "event": "media",
                        "media": {
                            "payload": base64_audio
                        }
                    }
                    await websocket.send(json.dumps(exotel_payload))
                    logging.info(f"Successfully sent {len(base64_audio)} bytes of audio to Exotel")
                except Exception as e:
                    logging.error(f"Error processing/sending audio: {e}", exc_info=True)
            else:
                logging.warning("Response contained no audio data")
    except Exception as e:
        logging.error(f"Error in forward_to_exotel main loop: {e}", exc_info=True)


async def handler(websocket):
    """Handles a single WebSocket connection from Exotel."""
    logging.info(f"New connection from {websocket.remote_address}")
    try:
        # 1. Wait for the 'start' message from Exotel
        start_message = await websocket.recv()
        start_data = json.loads(start_message)

        if start_data.get("event") == "start":
            stream_sid = start_data.get("stream_sid", "N/A")
            call_sid = start_data.get("start", {}).get("call_sid", "N/A")
            logging.info(f"[{stream_sid}] Call started for call SID: {call_sid}")
        else:
            logging.warning("First message was not a 'start' event. Closing connection.")
            return

        # 2. Initialize Gemini session
        # Using gemini-1.5-flash-preview-native-audio-dialog as it's specifically designed for audio dialog
        async with client.aio.live.connect(model="models/gemini-1.5-flash-preview-native-audio-dialog", config=GEMINI_CONFIG) as session:
            logging.info(f"[{stream_sid}] Gemini session started.")

            # 3. Start bidirectional streaming tasks
            to_gemini_task = asyncio.create_task(forward_to_gemini(websocket, session))
            to_exotel_task = asyncio.create_task(forward_to_exotel(websocket, session))

            # Wait for the to_gemini_task to complete (client disconnected or error)
            # but allow to_exotel_task to continue receiving responses
            await to_gemini_task
            
            # Give Gemini some time to process and respond
            logging.info(f"[{stream_sid}] Client disconnected. Waiting for final Gemini responses...")
            try:
                # Wait up to 10 seconds for any pending responses from Gemini
                await asyncio.wait_for(to_exotel_task, timeout=10.0)
            except asyncio.TimeoutError:
                logging.info(f"[{stream_sid}] Timeout waiting for Gemini responses.")
            except Exception as e:
                logging.error(f"[{stream_sid}] Error waiting for Gemini responses: {e}")
            finally:
                # Cancel the task if it's still running
                if not to_exotel_task.done():
                    to_exotel_task.cancel()
                    try:
                        await to_exotel_task
                    except asyncio.CancelledError:
                        pass
                logging.info(f"[{stream_sid}] Session tasks cleaned up.")

    except websockets.exceptions.ConnectionClosed as e:
        logging.info(f"Connection closed: {e}")
    except Exception as e:
        logging.error(f"An error occurred: {e}", exc_info=True)

# --- Main Server Logic ---

async def main():
    """Starts the WebSocket server."""
    port = int(os.environ.get("PORT", 8081))
    logging.info(f"Starting WebSocket server on port {port}...")
    async with websockets.serve(handler, "0.0.0.0", port):
        await asyncio.Future()  # Run forever

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("Server shutting down.")
